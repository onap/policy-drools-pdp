# The following properties control the IP address and port that a given
# server binds to. The default will bind to all interfaces on the host,
# and choose a port number at random.

#server.ipAddress=0.0.0.0
server.port=${{SERVER_POOL_PORT}}

# The following properties determine whether HTTPS is used -- note that HTTPS
# also requires that the 'java.net.ssl.*' parameters in 'system.properties' be
# specified, and the key store and trust store be configured, as appropriate.
server.https=${{SERVER_POOL_HTTPS}}
#server.selfSignedCerts=false

# The IP address and port that servers on the geo-redundant site
# should use to connect to servers on this site.
server.site.ip=${{SERVER_POOL_SITE_IP}}
server.site.port=${{SERVER_POOL_SITE_PORT}}

# A comma-separated list of host names -- if an entry is found that refers
# to an HTTP/HTTPS destination IP address, the host name will used as the
# destination, instead of the IP address
server.hostlist=${{SERVER_POOL_HOST_LIST}}

# The servers send 'pings' to each other once per main loop cycle. They
# also measure the gap between 'pings' from each server, and calculate
# an allowed time gap based upon this. 'server.allowedGap' is the initial
# allowed gap prior to receiving any pings (default=30 seconds), and
# 'server.adaptiveGapAdjust' is a value that is added to the calculated
# gap "just in case" (default=5 seconds)

#server.allowedGap=30000
#server.adaptiveGapAdjust=5000

# 'connectTimeout' and 'readTimeout' affect the client end of a REST
# connection (default=10 seconds each)

#server.connectTimeout=10000
#server.readTimeout=10000

# Each server has a thread pool per remote server, which is used when
# sending HTTP REST messages -- the following parameters determine the
# configuration.

#server.threads.corePoolSize=5
#server.threads.maximumPoolSize=10
#server.threads.keepAliveTime=5000

# The server pool members use a UEB/DMAAP topic to connect with other
# servers in the pool. The following set of parameters are passed to
# the CambriaClient library, and are used in setting up the consumer and
# publisher ends of the connection. 'discovery.servers' and 'discovery.topic'
# are the minimum values that need to be specified. The last parameter in
# this set, 'discovery.publisherLoopCycleTime' isn't passed to the
# CambriaClient library; instead, it controls how frequently the 'ping'
# messages are sent out on this channel. Note that only the lead server
# keeps this channel open long-term.

discovery.servers=${{SERVER_POOL_DISCOVERY_SERVERS}}
discovery.topic=${{SERVER_POOL_DISCOVERY_TOPIC}}
discovery.username=${{SERVER_POOL_DISCOVERY_USERNAME}}
discovery.password=${{SERVER_POOL_DISCOVERY_PASSWORD}}
discovery.https=${{DMAAP_USE_HTTPS}}
#discovery.apiKey=
#discovery.apiSecret=
#discovery.publisherSocketTimeout=5000
#discovery.consumerSocketTimeout=70000
#discovery.fetchTimeout=60000
#discovery.fetchLimit=100
#discovery.selfSignedCertificates=false
#discovery.publisherLoopCycleTime=5000

# The 'leader.*' parameters affect behavior during an election. The value of
# 'mainLoop.cycle' determines the actual time delay. 'leader.stableIdCycles'
# is the required minimum number of "stable" cycles before voting can start
# (in this case, "stable" means no servers added or failing). Once voting has
# started, "leader.stableVotingCycles' is the minimum number of "stable"
# cycles needed before declaring a winner (in this case, "stable" means no
# votes changing).

#leader.stableIdleCycles=5
#leader.stableVotingCycles=5

# The value of 'mainLoop.cycle' (default = 1 second) determines how frequently
# various events occur, such as the sending of 'ping' messages, and the
# duration of a "cycle" while voting for a lead server.

#mainLoop.cycle=1000

# 'keyword.path' is used when looking for "keywords" within JSON messages.
# The first keyword located is hashed to determine which bucket to route
# through.

keyword.path=requestID,CommonHeader.RequestID,body.output.common-header.request-id,result-info.request-id:uuid
# 'keyword.<CLASS-NAME>.lookup' is used to locate "keywords" within objects.
# The 'value' field contains a list of method calls or field names separated
# by '.' that are used to locate the keyword
# (e.g. 'method1().field2.method3()')

keyword.org.onap.policy.m2.base.Transaction.lookup=getRequestID()
keyword.org.onap.policy.controlloop.ControlLoopEvent.lookup=requestID
keyword.com.att.ecomp.policy.controlloop.OpenLoopEvent.lookup=requestID
keyword.org.onap.policy.appclcm.LcmRequestWrapper.lookup=getBody().getCommonHeader().getRequestId()
keyword.org.onap.policy.appclcm.LcmResponseWrapper.lookup=getBody().getCommonHeader().getRequestId()
keyword.com.att.ecomp.policy.m2.sdno.model.SdnoDmaapWrapper.lookup=getResultInfo().getRequestId():uuid
keyword.com.att.ecomp.policy.controlloop.OpexControlLoopEvent.lookup=getRequestID()
keyword.com.att.ecomp.policy.controlloop.SIAEvent.lookup=getRawData().requestID
keyword.com.att.ecomp.policy.controlloop.SIAEvents.lookup=getSiaRawDataRequestID()
keyword.com.att.ecomp.policy.m2.sdnr.opex.model.SdnrSleepRequest.lookup=requestID
keyword.com.att.ecomp.policy.m2.sdnr.opex.model.RBCandidateList.lookup=requestID
keyword.com.att.ecomp.policy.m2.sdnr.opex.model.SdnrWakeupRecord.lookup=requestID
keyword.com.att.ecomp.policy.m2.sdnr.opex.model.SdnrWakeupRequest.lookup=requestID
keyword.org.onap.policy.drools.serverpool.TargetLock.lookup=getOwnerKey()
keyword.org.onap.carson.city.inventory.client.models.V1SdnrAction.lookup=getRequestID()
keyword.org.onap.carson.city.inventory.client.models.V1PciRsiResponse.lookup=getRequestID()
keyword.org.onap.carson.city.inventory.client.models.V1PciRsiPolicyResponse.lookup=getRequestID()
keyword.org.onap.carson.city.inventory.client.models.V1Rollback.lookup=getRequestID()
keyword.com.att.ecomp.policy.controlloop.PciRsiControlLoopEvent.lookup=getRequestID()
keyword.com.att.ecomp.policy.controlloop.TrafficOffloadControlLoopEvent.lookup=getRequestID()

# The following properties affect distributed 'TargetLock' behavior.
#
#   lock.ttl - controls how many hops a 'TargetLock' message can take
#   lock.audit.period - how frequently should the audit run?
#   lock.audit.gracePeriod - how long to wait after bucket reassignments
#       before running the audit again
#   lock.audit.retryDelay - mismatches can occur due to the transient nature
#       of the lock state: this property controls how long to wait before
#       trying again

#lock.ttl=3
#lock.audit.period=300000
#lock.audit.gracePeriod=60000
#lock.audit.retryDelay=5000
