###
# ============LICENSE_START=======================================================
# feature-server-pool
# ================================================================================
# Copyright (C) 2020 AT&T Intellectual Property. All rights reserved.
# ================================================================================
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============LICENSE_END=========================================================
###

# The following properties control the IP address and port that a given
# server binds to. The default will bind to all interfaces on the host,
# and choose a port number at random.

server.pool.server.ipAddress=${envd:SERVER_POOL_SERVER_IP:127.0.0.1}
server.pool.server.port=${envd:SERVER_POOL_PORT:20000}

# The following properties determine whether HTTPS is used -- note that HTTPS
# also requires that the 'java.net.ssl.*' parameters in 'system.properties' be
# specified, and the key store and trust store be configured, as appropriate.
server.pool.server.https=${envd:SERVER_POOL_HTTPS}
server.pool.server.selfSignedCerts=false

# The IP address and port that servers on the geo-redundant site
# should use to connect to servers on this site.
server.pool.server.site.ip=${envd:SERVER_POOL_SITE_IP}
server.pool.server.site.port=${envd:SERVER_POOL_SITE_PORT}

# A comma-separated list of host names -- if an entry is found that refers
# to an HTTP/HTTPS destination IP address, the host name will used as the
# destination, instead of the IP address
server.pool.server.hostlist=${envd:SERVER_POOL_HOST_LIST}

# The servers send 'pings' to each other once per main loop cycle. They
# also measure the gap between 'pings' from each server, and calculate
# an allowed time gap based upon this. 'server.pool.server.allowedGap' is the initial
# allowed gap prior to receiving any pings (default=30 seconds), and
# 'server.pool.server.adaptiveGapAdjust' is a value that is added to the calculated
# gap "just in case" (default=5 seconds)

server.pool.server.allowedGap=30000
server.pool.server.adaptiveGapAdjust=5000

# 'connectTimeout' and 'readTimeout' affect the client end of a REST
# connection (default=10 seconds each)

server.pool.server.connectTimeout=10000
server.pool.server.readTimeout=10000

# Each server has a thread pool per remote server, which is used when
# sending HTTP REST messages -- the following parameters determine the
# configuration.

server.pool.server.threads.corePoolSize=5
server.pool.server.threads.maximumPoolSize=10
server.pool.server.threads.keepAliveTime=5000

# The server pool members use a UEB/DMAAP topic to connect with other
# servers in the pool. The following set of parameters are passed to
# the CambriaClient library, and are used in setting up the consumer and
# publisher ends of the connection. 'discovery.servers' and 'discovery.topic'
# are the minimum values that need to be specified. The last parameter in
# this set, 'discovery.publisherLoopCycleTime' isn't passed to the
# CambriaClient library; instead, it controls how frequently the 'ping'
# messages are sent out on this channel. Note that only the lead server
# keeps this channel open long-term.

server.pool.discovery.servers=${envd:SERVER_POOL_DISCOVERY_SERVERS:127.0.0.1}
server.pool.discovery.port=${envd:SERVER_POOL_DISCOVERY_PORT:3904}
server.pool.discovery.topic=${envd:SERVER_POOL_DISCOVERY_TOPIC:DISCOVERY-TOPIC}
server.pool.discovery.username=${envd:SERVER_POOL_DISCOVERY_USERNAME}
server.pool.discovery.password=${envd:SERVER_POOL_DISCOVERY_PASSWORD}
server.pool.discovery.https=${envd:DMAAP_USE_HTTPS}
server.pool.discovery.apiKey=
server.pool.discovery.apiSecret=
#server.pool.discovery.publisherSocketTimeout=5000
#server.pool.discovery.consumerSocketTimeout=70000
server.pool.discovery.fetchTimeout=60000
server.pool.discovery.fetchLimit=100
server.pool.discovery.selfSignedCertificates=false
server.pool.discovery.publisherLoopCycleTime=5000

# The 'leader.*' parameters affect behavior during an election. The value of
# 'mainLoop.cycle' determines the actual time delay. 'leader.stableIdCycles'
# is the required minimum number of "stable" cycles before voting can start
# (in this case, "stable" means no servers added or failing). Once voting has
# started, "leader.stableVotingCycles' is the minimum number of "stable"
# cycles needed before declaring a winner (in this case, "stable" means no
# votes changing).

server.pool.leader.stableIdleCycles=5
server.pool.leader.stableVotingCycles=5

# The value of 'mainLoop.cycle' (default = 1 second) determines how frequently
# various events occur, such as the sending of 'ping' messages, and the
# duration of a "cycle" while voting for a lead server.

server.pool.mainLoop.cycle=1000

# 'keyword.path' is used when looking for "keywords" within JSON messages.
# The first keyword located is hashed to determine which bucket to route
# through.

keyword.path=requestID,CommonHeader.RequestID,body.output.common-header.request-id,result-info.request-id:uuid
# 'keyword.<CLASS-NAME>.lookup' is used to locate "keywords" within objects.
# The 'value' field contains a list of method calls or field names separated
# by '.' that are used to locate the keyword
# (e.g. 'method1().field2.method3()')

keyword.java.lang.String.lookup=toString()
keyword.org.onap.policy.m2.base.Transaction.lookup=getRequestID()
keyword.org.onap.policy.controlloop.ControlLoopEvent.lookup=requestID
keyword.org.onap.policy.appclcm.LcmRequestWrapper.lookup=getBody().getCommonHeader().getRequestId()
keyword.org.onap.policy.appclcm.LcmResponseWrapper.lookup=getBody().getCommonHeader().getRequestId()
keyword.org.onap.policy.drools.serverpool.TargetLock.lookup=getOwnerKey()
keyword.org.onap.policy.drools.serverpooltest.TestDroolsObject.lookup=getKey()
keyword.org.onap.policy.drools.serverpooltest.Test1$KeywordWrapper.lookup=key

# The following properties affect distributed 'TargetLock' behavior.
#
#   server.pool.lock.ttl - controls how many hops a 'TargetLock' message can take
#   server.pool.lock.audit.period - how frequently should the audit run?
#   server.pool.lock.audit.gracePeriod - how long to wait after bucket reassignments
#       before running the audit again
#   server.pool.lock.audit.retryDelay - mismatches can occur due to the transient nature
#       of the lock state: this property controls how long to wait before
#       trying again

server.pool.lock.ttl=3
server.pool.lock.audit.period=300000
server.pool.lock.audit.gracePeriod=60000
server.pool.lock.audit.retryDelay=5000